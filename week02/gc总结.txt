1.串行gc：串行 GC 对年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep-compact（标记-清除整理）算法；每次gc都stw且单线程执行，清理速度较慢，故每次暂停时间较长；这种情况容易造成业务阻塞（吞吐量减少）；经过测试分析40%左右的gc都在40到50ms。

2.并行gc：GC 对年轻代使用 mark-copy（标记-复制） 算法，对老年代使用 mark-sweep-compact（标记-清除整理）算法；每次gc都stw且多线程（默认cpu的核心数，也可配置）执行，清理速度较快，故总体暂停时间较短；经过测试分析60%左右的gc都在10ms以内，最大耗时30-40ms占36%。

3.CMS GC：年轻代采用并行 STW 方式的 mark-copy (标记-复制)算法，对老年代主要使用并发 mark-sweep (
标记-清除)算法，不对老年代整理，而使用空闲列表来管理内存空间的回收，mark-sweep阶段和应用线程一起工作，默认情况mark-sweep阶段的并发线程数为cpu核心数的4分之1，主要目标是降低 GC 停顿导致的系统延迟；经过测试分析50%左右的gc都在10ms以内，最大耗时50-60ms占16%。

4.G1：
4.1 堆不再分成年轻代和老年代，而是划分为多个（通常是2048个）可以存放对象的小块堆区域(smaller heap regions)。每个小块，可能一会被定义成 Eden 区，一会被指定为 Survivor区或者Old 区。在逻辑上，所有的 Eden 区和 Survivor 区合起来就是年轻代，所有的 Old 区拼在一起那就是老年代。
4.2 主要的设计目标是：将 STW 停顿的时间和分布，变成可预期且可配置的。
4.3 在并发阶段估算每个小堆块存活对象的总数。构建回收集的原则是：垃圾最多的小块会被优先收集。
4.4 经过测试分析100%左右的gc都在10ms以内，系统暂停时间较短，从而减少系统的业务阻塞。
